---
title: "FlutterBoost3.0：双层路由栈设计方案"
date: 2021-02-24
---

## 需求分析
[FlutterBoost](https://github.com/alibaba/flutter_boost)的核心能力是，在复用引擎的前提下，提供一套机制和接口，确保Native页面与Flutter页面混合的业务场景下能够正确导航，包括Tab场景下的平级导航。

我们可以将混合开发的业务大致分为普通场景和Tab场景。

### 普通场景
在普通场景下，混合页面导航历史类似下图所示（其中，N表示Native页面，F表示Flutter页面）：
![](/memo/docs/assets/images/2021-02-24-fig-3-svg.svg)

在混合栈访问历史中，Native页面和Flutter页面可能以任意顺序出现，但不外乎以下几种场景：
1. 当前页面是Native页面，下一个页面是Native页面，或Flutter页面；
2. 当前页面是Flutter页面，下一个页面是Native页面，或Flutter页面；

#### 1 当前是Native页面
##### 1.1 打开Flutter页面
在当前页面是Native页面的场景下，如果需要打开一个Flutter页面，那么我们首先需要创建一个「容器」来显示Flutter页面，然后通知Dart侧打开特定的路由。这里可以将“通知Dart侧打开特定路由”的操作封装到「容器」的创建过程中，减少接口暴露。
>「容器」是指，Android平台上的FlutterActivity/FlutterFragment、IOS上的FlutterViewController，或者业务自定义View等承载FlutterView的对象。

##### 1.2 后退到Flutter页面
如果当前是Native页面，前一个页面是Flutter页面，那么后退时平台会将当前Native页面从Native栈的栈顶撤走，而前一个承载Flutter页面的容器会出现在栈顶。

所以，这种场景我们也不需要额外处理。

##### 1.3 打开Native页面
从Native页面打开或后退到另一个Native页面的场景，平台侧都可以很好地处理，不需要我们特别考虑。

##### 1.4 后退到Native页面
也不需要特别处理。

#### 2 当前是Flutter页面
##### 2.1 打开Flutter页面
如果当前是Flutter页面，那么打开另外一个Flutter页面时，有两种方案可选：
1. 在当前「容器」打开：类似于纯Flutter应用中打开页面的方式，不需要平台侧感知；
2. 在新的一个「容器」中打开：需要通知平台侧创建一个容器（然后打开特定路由）；

为了方便描述，我们这里将需要重新创建容器的路由称为「外部路由」，不需要创建容器的路由称为「内部路由」。

##### 2.2 后退到Flutter页面
当前是Flutter页面，后退到前一个Flutter页面，有两种场景：
1. 如果当前Flutter页面是「外部路由」，那么在弹出Dart侧的路由栈的同时，还需要将平台侧的容器从Native栈弹出；
2. 如果当前Flutter页面是「内部路由」，那么只需要弹出Dart侧的路由栈即可。

##### 2.3 打开Native页面
从Flutter页面打开Native页面，只需通知平台侧创建对应的Native页面即可。

##### 2.4 后退到Native页面
从Flutter页面后退到Native页面的场景下，当前的Flutter页面只能是「外部路由」，Dart侧和Native侧的栈都需要弹出。

### Tab场景
如图例所示，承载Tab的页面是一个Native页面，而每个Tab可以是Native页面，或者Flutter页面。
![](/memo/docs/assets/images/2021-02-24-fig-2-svg.svg)

在不涉及到Flutter页面的情况下，Tab场景也与普通场景一样，平台能够处理好Native页面，不需要额外处理。<u>Tab场景的特别之处是，Tab之间可以任意切换，而单个Tab的内部导航历史需要保持正确有序，这需要Dart侧支持双层路由栈。</u>

![](/memo/docs/assets/images/2021-02-24-fig-4-svg.svg)

<u>可以预期的是，如果Tab的首个页面就是Flutter页面，那么该Flutter页面肯定是外部路由，并且其页面显示区域是Tab的正常显示区域，不会覆盖下面的Tab bar。而，对于非Tab首页的Flutter页面，如果是外部路由，那么它的容器会覆盖整个屏幕，Tab bar不再可见；如果是内部路由，那么其页面显示区域是Tab的正常显示区域，不会覆盖下面的Tab bar。</u>

## 核心能力
通过上面对业务场景的分析，我们认为一个基本的混合路由栈解决方案需要具备以下能力：
1. 需要维护Flutter页面的历史栈，可以不用关心Native页面的栈；
2. Flutter页面的历史栈需要区分外部路由和内部路由；
3. Flutter页面的历史栈需要支持平级导航，以满足Tab场景
4. 平台侧与Dart侧能够便捷通信，以发送请求或回调；

本文将重点阐述Flutter页面历史栈的设计思路和方案，其他点只做简单介绍或直接略过。


## 方案设计

### 设计思路
根据Tab场景，我们很容易想到一种双层路由栈结构：
>外层栈用于维护Tab之间的路由关系，内层栈用于记录每个Tab页的内部访问历史。因为Tab之间可以任意切换，所以外层栈需要支持将栈中的任意元素移到栈顶。

该方案最大的问题是，<u>需要用户知道每个Tab首页是Flutter的页面（该页面需要记录在外层栈），但这并不容易，很容易出错</u>。此外，接口设计也会跟着变得复杂，易用性变差。

那么，有没有办法，模糊掉Tab的概念呢？用户就可以不用care当前是否是Tab场景。

答案是，有的。

我们前面提到，Flutter页面分为外部路由和内部路由，也就是自带容器的Flutter页面和复用他人容器的Flutter页面。外部路由可以看着是容器页面，内部路由是普通页面，容器页面可以管理或者附属多个普通页面。在Tab场景下，<u>Tab首页是Flutter的页面一定是一个外部路由，Tab的内部访问历史便是内部路由（外部路由成不了Tab的内部访问历史）。</u>

打开的Flutter页面是否是外部路由，是由业务场景决定的（例如，从Native页面打开的Flutter页面一定是外部路由，业务从Flutter页面打开另一个Flutter页面时明确要求带容器），不需要用户刻意区分。如果我们<b><u>将双层路由栈的外层栈用于管理容器（外部路由），而内层栈用于存放实际的Flutter页面（内部路由）</u></b>，那么用户不需要关心当前Flutter页面是否处于Tab场景也能很好地支持。

除了可以支持常见的Tab场景外，一些更复杂的混合场景也能覆盖。

### 最终实现
FlutterBoost3.0最终采用的双层路由栈结构如下图所示。

![](/memo/docs/assets/images/2021-02-24-fig-1-svg.svg)

该二维结构分为内外两层栈，外层栈存放外部路由，支持栈内元素位置任意变更，内层栈存放内部路由。

这里的双层栈，我们采用overlay + Navigator2.0的方式实现。外层栈使用overlay管理，而内层栈使用Navigator2.0实现——2.0声明式语法支持栈内元素位置的灵活变更。该方案的优点是，充分利用原生能力，代码结构简单，能够比较友好地支持原生Navigator的一些能力。
